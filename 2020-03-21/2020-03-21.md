#### 1.写出下面代码的执行结果（画图）
+ {fn: (function () {...}()}
+ window

#### 2.写出下面代码的输出结果
+ undefined
+ language

#### 3.写出下面代码的输出结果
+ window

#### 4.写出下面代码的输出结果（画图）
+ "24"

#### 5.写出下面代码的输出结果
+ "12"

#### 6.写出下面代码的输出结果（画图）
+ 22
+ 23
+ 65 30

#### 7.以下代码的功能是要实现为5个input按钮循环绑定click点击事件，绑定完成后点击1、2、3、4、5五个按钮分别会alert输出0、1、2、3、4五个字符。（腾讯）
+ 请问如下代码是否能实现？
不能
+ 如果不能实现那么现在的效果是什么样的？
不管点那个按钮，输出都是"5"
+ 应该做怎样的修改才能达到我们想要的效果，并说明原理？
将for循环中申明变量的方法由var改换成let；
使用 let 可以在当前代码块创建块级作用域, 并将自己与之绑定。for 循环的条件句柄处实际上是一个父级作用域, 而代码块体内则是子作用域, 每轮循环都会创建新的块级作用域来保存当前循环的 i 值, 当事件触发函数执行的时候就会到自己对应的块级作用域中去寻找 i 值, 所以可以解决题目的问题。

#### 8.你理解的闭包作用是什么，优缺点？
+ 闭包具有保护作用
    + 优点：团队开发中可以方式代码被污染；封装插件或类库，可以使用闭包方式我们定义的变量与用户定义的变量冲突
    + 缺点：闭包每次运行都会形成一个私有的上下文，同时要调用闭包中的内容时，该上下文回因为内容被占用而无法释放，会占用很多内存，影响计算机性能  

#### 9.简述let和var的区别
+ 1.var定义变量存在代码加载前存在变量提升，而let不存在
+ 2.var定义变量可以重复声明；而let定义的变量在当前上下文中只要已经申明过，就不能在基于let重复声明，否则会在词法解析阶段报错，当前代码都不会被执行
+ 3.var在全局上下文中申明变量时，同时会在GO(window)中设置一个属性，而且两者存在映射机制；let声明的变量仅是全局变量，与GO无关
+ 4.除对象/函数等大括号之外，如果在其与的大括号中（如判断、循环）出现let，则会把当前大括号包起来形成独立的私有上下文，同时基于let申明的变量时当前块级作用域内的私有变量

#### 10.改造下面代码，使之输出0~9
for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}

#### 11.下面代码的输出结果是多少，为什么？如何改造一下，就能让其输出 20 10？
+ 输出结果是
    + b() {
        b = 20;
        console.log(b);
    }
    + 10
该代码自执行函数中函数名为b，函数的`b = 20`并不是申明私有变量b，而是相当于在自执行函数内修改函数名，但是在自执行函数内对函数名的修改是无效的，并不能输出20，可以将其用var或let修改为申明变量b。
+   var b = 10;
    (function b() {
        var b = 20;// let b =20;
        console.log(b);
    })();
    console.log(b);